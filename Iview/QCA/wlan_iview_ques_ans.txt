Qualcomm Hyd wlan Interview questions:
======================================

Linux:
------
1.   what is tophalf and bottom half ?
Ans: The generic problem of any ISR is it's latency. Since most often the corresponding interrupt is disabled during the execution of a ISR, the ISR 
     is expected to be short.But, what if you have to do a lot of data processing, memory allocation in a ISR. Linux overcomes this problem by 
     providing an infrastructure in the kernel to split a ISR into 

     Top-Half: This is the critical section. The interrupt is disabled when this is executed. The top half saves device data to a device-specific 
     buffer, schedules its bottom half, and exits: this is very fast.
     Bottom-Half: This is the less critical section. The interrupt is enable when this is executed. Once the Top-Half schedule bottom halves then it 
     performs whatever other work is required, such as awakening processes, starting up another I/O operation, and so on. 
     
     This setup permits the top half to service a new interrupt while the bottom half is still working.
     Linux provides some techinques to implement a bottom half.

     Tasklets          <= actually a subset of item no.3 SoftIRQ
     Workqueues
     SoftIRQ's
     
     Tasklet is simple. All rules of an ISR applies to a tasklet also. ie., a tasklet cannot sleep as it runs in a interrupt context. You generally 
     initialize a tasklet in the probe function of your driver using, `tasklet_init(xxxx);` then in your top-half of your ISR you will schedule the 
     tasklet using `tasklet_schedule(xxxx);` and return IRQ_HANDLED. The tasklet generally gets scheduled immediately if no other interrupt occurs.
     Also, the tasklet gets scheduled in the same CPU, in which the ISR was handled. It is generally atomic in nature. Ofcourse, interrupts are
     enabled in a tasklet. 

    Workques concept is similar to a tasklet. The only major difference being it is executed in process context. So, you can call functions that can 
    sleep. For most cases, a tasklet is sufficient unless you need to sleep in a bottom-half.

    SoftIRQ's I am not covering this as it is generally not used in device drivers and it used internally in kernel for managing tasklets etc... 
    There are fixed number of softIRQ's configured at compile time.
    
2.   what will happen if you put sleep in interrupt handler ?
Ans: Using sleep in interrupt handler cause kernel crash. Interrupt can occurs anytime and in process of ISR the same time of interrupt is disabled.
     If we use sleep in interrupt hendler, kernel is in intermediate state. Other processor can't execute kernel calls, because it's already busy. 
     Each will be forced to pause waiting for the kernel which is not coming back.
     You can't sleep in an interrupt handler because interrupts do not have a backing process context and thus there is nothing to reschedule back 
     into. In other words, interrupt handlers are not associated with task, so there is nothing to "put to sleep" and "nothing to wake". They must 
     run automically.

3.   Extension: context switch, process/interrupt context, gpio to interrupt handler
ANS: 
4.   What is MMU
Ans: The memory-management unit (MMU) is the hardware responsible for implementing virtual memory. Using this logical address is mapped to its 
     corresponding physical address.
     Transparently handles all memory accesses from Load/Store instructions.
     Maps accesses using virtual addresses to system RAM
     Maps accesses using virtual addresses to memory-mapped peripheral hardware
     Handles permissions
     Generates an exception (page fault) on an invalid access
     
5.   diff b/w virtual address and physical address
Ans: Address generated by CPU while a program is running is referred as Logical Address. The logical address is virtual as it does not exist 
     physically. Hence, it is also called as Virtual Address. This address is used as a reference to access the physical memory location. The set of
     all logical addresses generated by a programs perspective is called Logical Address Space. everyone has virtual address and its size depends on
     your system(Linux running 32-bit has 4GB address space)
     
     Physical address: The address you'll never reach if you're running on top of an OS. It's where your data, regardless of its virtual address, 
     resides in RAM. This will change if your data is sent back and forth to the hard disk to accommodate more space for other processes.

6.   what is use of virtual address
Ans: Virtual memory is a memory management capability of an operating system (OS) that uses hardware and software to allow a computer to compensate 
     for physical memory shortages by temporarily transferring data from random access memory (RAM) to disk storage. Virtual address space is 
     increased using active memory in RAM and inactive memory in hard disk drives (HDDs) to form contiguous addresses that hold both the application 
     and its data.
     The range of virtual addresses that is available to a process is called the virtual address space for the process. Each user-mode process has 
     its own private virtual address space. For a 32-bit process, the virtual address space is usually the 4-gigabyte range 0x00000000 through 
     0xFFFFFFFF. A range of virtual addresses is sometimes called a range of virtual memory.
     The size of virtual storage is limited by the addressing scheme of the computer system and amount of secondary memory is available not by the 
     actual number of the main storage locations.


7.   Advantages and disadvantage in virtual address
Ans: Advantages: The primary advantage or objective of Virtual Memory systems is the ability to load and execute a process that requires a larger 
                 amount of memory than what is available by loading the process in parts and then executing them.
                 A program can use a contiguous range of virtual addresses to access a large memory buffer that is not contiguous in physical memory.
                 The virtual addresses used by different processes are isolated from each other. The code in one process cannot alter the physical 
                 memory that is being used by another process or the operating system.                 
                 A program can use a range of virtual addresses to access a memory buffer that is larger than the available physical memory. As the 
                 supply of physical memory becomes small, the memory manager saves pages of physical memory (typically 4 kilobytes in size) to a 
                 disk file. Pages of data or code are moved between physical memory and the disk as needed.
                 More processes may be maintained in the main memory: Because we are going to load only some of the pages of any particular process, 
                 there is room for more processes. This leads to more efficient utilization of the processor because it is more likely that at least 
                 one of the more numerous processes will be in the ready state at any particular time.
                 
     Disadvantage: virtual memory that increased overhead for handling paging interrupts, software complexity and hardware costs.
                   It takes more time to switch between applications
                   Less hard drive space for your use.

8.   Demand Paging
Ans: The basic idea behind demand paging is that when a process is swapped in, its pages are not swapped in all at once. Rather they are swapped in 
     only when the process needs them(On demand). This is termed as lazy swapper, although a pager is a more accurate term. The demand paging 
     working is based on a page table implementation. The page table maps logical memory to physical memory. The page table uses a bitwise operator 
     to mark if a page is valid or invalid. A valid page is one that currently resides in main memory. An invalid page can be defined as the one 
     that currently resides in secondary memory. When a process tries to access a page, the following will happen.
        1. Attempt to access the page
        2. The page is valid. Page processing instruction continues as normal.
        3. If the page is an invalid one, then a page-fault trap occurs.
        4. The memory reference is then checked to determine if it is a valid reference to a location on secondary memory or not. If not, the 
           process is terminated (illegal memory access). Otherwise, the required page is paged in.
        5. Now the disk operation to read the desired page into main memory is scheduled.
        6. Finally, the instruction that was interrupted by the operating system trap is restarted.
     
8.   Page tables
Ans: Page table has page table entries where each page table entry stores a frame number and optional status (like protection) bits. Many of status 
     bits used in the virtual memory system. The most important thing in PTE is frame Number.
     The entries in the TLB are a limited resource. Far more mappings can be made than can exist in the TLB at one time.
     The kernel must keep track of all of the mappings all of the time. The kernel stores all this information in the page tables.
     
                   |<-------------------------- optional --------------------->|
      _________________________________________________________________________
     |             |                |            |           |         |       |
     |Frame number | Present/Absent | Protection | Reference | Caching | Dirty |
     |_____________|________________|____________|___________|_________|_______|
     
     Frame Number : It gives the frame number in which the current page you are looking for is present. The number of bits required depends on the 
                    number of frames.Frame bit is also known as address translation bit.
                    Number of bits for frame = Size of physical memory/frame size
     Present/Absent bit : Present or absent bit says whether a particular page you are looking for is present or absent. In case if it is not present, that is called Page Fault. It is set to 0 if the corresponding page is not in memory. Used to control page fault by the operating system to support virtual memory. Sometimes this bit is also known as valid/invalid bits.
Protection bit – Protection bit says that what kind of protection you want on that page. So, these bit for the protection of the page frame (read, write etc).
Referenced bit – Referenced bit will say whether this page has been referred in the last clock cycle or not. It is set to 1 by hardware when the page is accessed.
Caching enabled/disabled – Some times we need the fresh data. Let us say the user is typing some information from the keyboard and your program should run according to the input given by the user. In that case, the information will come into the main memory. Therefore main memory contains the latest information which is typed by the user. Now if you try to put that page in the cache, that cache will show the old information. So whenever freshness is required, we don’t want to go for caching or many levels of the memory.The information present in the closest level to the CPU and the information present in the closest level to the user might be different. So we want the information has to be consistency, which means whatever information user has given, CPU should be able to see it as first as possible. That is the reason we want to disable caching. So, this bit enables or disable caching of the page.
Modified bit – Modified bit says whether the page has been modified or not. Modified means sometimes you might try to write something on to the page. If a page is modified, then whenever you should replace that page with some other page, then the modified information should be kept on the hard disk or it has to be written back or it has to be saved back. It is set to 1 by hardware on write-access to page which is used to avoid writing when swapped out. Sometimes this modified bit is also called as the Dirty bit.

9.   Page fault
Ans: A page fault is a CPU exception, generated when software attempts to use an invalid virtual address. There are three cases:
        - The virtual address is not mapped for the process requesting it.
        - The processes has insufficient permissions for the address requested.
        - The virtual address is valid, but swapped out (This is a software condition)
        
10.  Page swap
Ans: 

11. page thrashing
12. what is the use of paging ?
13. stages of compilation?
14. what is scheduler, who will send segmentation fault signal 
15. system calls
